/**-----------------------------------------------------------------------------------------
* Copyright Â© 2023 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the package root for more information
*-------------------------------------------------------------------------------------------*/
"use client";
import * as n from "react";
import d from "prop-types";
import { provideIntlService as D, registerForIntl as ne } from "@progress/kendo-react-intl";
import { chartBaseTheme as T, InstanceObserver as x, DomEventsBuilder as ae, Chart as ie, Sparkline as A, StockChart as oe } from "@progress/kendo-charts";
import { canUseDOM as M, classNames as S, validatePackage as le, shouldShowValidationUI as ce, WatermarkOverlay as he, SvgIcon as pe } from "@progress/kendo-react-common";
import { Popup as de } from "@progress/kendo-react-popup";
import { Breadcrumb as ue } from "@progress/kendo-react-layout";
import { homeIcon as me } from "@progress/kendo-svg-icons";
function H(t, e) {
  let s = t;
  for (; s && s !== e; )
    s = s.parentNode;
  return !!s;
}
function C(t, e, s, r) {
  const a = t[e];
  if (a && Array.isArray(a)) {
    for (let i of a)
      if (!i.type || i.type !== r)
        return new Error(
          `${s} children should be Array of type ${r.displayName}.`
        );
  }
  return null;
}
const N = (t) => t === void 0 ? !1 : !t, ve = (t) => ({
  x: {
    location: t.pageX
  },
  y: {
    location: t.pageY
  }
}), fe = (t, e) => {
  const s = t.pointers, r = s[0], a = r.pageX, i = r.pageY;
  let c = 0;
  if (s.length > 1) {
    const l = s[0], h = s[1];
    c = Math.sqrt(Math.pow(l.pageX - h.pageX, 2) + Math.pow(l.pageY - h.pageY, 2));
  }
  return {
    distance: c,
    event: t.srcEvent,
    preventDefault: function() {
      t.preventDefault();
    },
    target: t.target,
    touches: s.map(ve),
    type: t.type,
    x: {
      delta: e ? a - e.x.location : 0,
      initialDelta: t.deltaX,
      location: a,
      startLocation: a - t.deltaX
    },
    y: {
      delta: e ? i - e.y.location : 0,
      initialDelta: t.deltaY,
      location: i,
      startLocation: i - t.deltaY
    }
  };
};
function ye(t, e) {
  for (let s = 0; s < t.length; s++)
    if (e[t[s]])
      return !0;
  return !1;
}
const O = [{
  end: "panend",
  move: "panmove",
  start: "panstart"
}, {
  gesturechange: "pinchmove",
  gestureend: "pinchend",
  gesturestart: "pinchstart"
}, {
  press: "press"
}, {
  tap: "tap"
}];
class ge {
  constructor(e, s) {
    this.hammerInstance = e, this.eventHandlers = {}, this.tap = this.tap.bind(this), this.press = this.press.bind(this), this.panstart = this.panstart.bind(this), this.panmove = this.panmove.bind(this), this.panend = this.panend.bind(this), this.pinchstart = this.pinchstart.bind(this), this.pinchmove = this.pinchmove.bind(this), this.pinchend = this.pinchend.bind(this), s && this.bind(s);
  }
  tap(e) {
    this.trigger("tap", e);
  }
  press(e) {
    this.trigger("press", e);
  }
  panstart(e) {
    delete this.previous, this.previous = this.trigger("start", e);
  }
  panmove(e) {
    this.previous = this.trigger("move", e);
  }
  panend(e) {
    this.trigger("end", e), delete this.previous;
  }
  pinchstart(e) {
    this.trigger("gesturestart", e);
  }
  pinchmove(e) {
    this.trigger("gesturechange", e);
  }
  pinchend(e) {
    this.trigger("gestureend", e);
  }
  trigger(e, s) {
    const r = fe(s, this.previous);
    return this.eventHandlers[e] && this.eventHandlers[e](r), r;
  }
  bind(e = {}) {
    this.unbind(), this.eventHandlers = e;
    for (let s = 0; s < O.length; s++) {
      const r = O[s], a = Object.keys(r);
      if (ye(a, e))
        for (let i = 0; i < a.length; i++) {
          const c = r[a[i]];
          this.hammerInstance.on(c, this[c]);
        }
    }
  }
  unbind() {
    this.hammerInstance && this.hammerInstance.off(), this.eventHandlers = {};
  }
  destroy() {
    this.hammerInstance && (this.hammerInstance.destroy(), delete this.hammerInstance), delete this.eventHandlers;
  }
  toggleDrag(e) {
    this.toggle("pan", e);
  }
  toggleZoom(e) {
    this.toggle("pinch", e);
  }
  toggle(e, s) {
    this.hammerInstance && this.hammerInstance.get(e).set({
      enable: s
    });
  }
}
const Ce = "Hammerjs is not loaded.Solution: http://www.telerik.com/kendo-react-ui/components/charts/troubleshooting/#toc-installation";
class xe {
  static create(e, s) {
    if (typeof window < "u") {
      const r = window.Hammer;
      if (!r) {
        process.env.NODE_ENV !== "production" && console.warn(Ce);
        return;
      }
      const a = new r(e, {
        recognizers: [
          [r.Tap],
          [r.Pan],
          [r.Pinch],
          [r.Press, { time: 0 }]
        ]
      });
      return new ge(a, s);
    }
  }
}
class v {
  /**
   * @hidden
   */
  constructor(e) {
    this.target = e;
  }
}
class be extends v {
  /**
   * @hidden
   */
  constructor(e, s) {
    super(s), this.axis = e.axis, this.dataItem = e.dataItem, this.index = e.index, this.text = e.text, this.value = e.value;
  }
}
class f extends v {
  constructor() {
    super(...arguments), this.prevented = !1;
  }
  /* eslint-disable max-len */
  /**
   * Prevents the default action for a specified event. In this way, the source component suppresses the built-in behavior that follows the event.
   */
  preventDefault() {
    this.prevented = !0;
  }
  /**
   * Returns `true` if the event was prevented by any of its subscribers.
   *
   * @returns `true` if the default action was prevented.
   * Otherwise, returns `false`.
   */
  isDefaultPrevented() {
    return this.prevented;
  }
}
class Se extends f {
  /**
   * @hidden
   */
  constructor(e, s) {
    super(s), this.axisRanges = e.axisRanges, this.nativeEvent = e.originalEvent;
  }
}
class Ee extends v {
  /**
   * @hidden
   */
  constructor(e, s) {
    super(s), this.axisRanges = e.axisRanges, this.nativeEvent = e.originalEvent;
  }
}
class Ie extends f {
  /**
   * @hidden
   */
  constructor(e, s) {
    super(s), this.axisRanges = e.axisRanges, this.nativeEvent = e.originalEvent;
  }
}
class V extends v {
  /**
   * @hidden
   */
  constructor(e, s) {
    super(s), this.value = e.value, this.point = e.point, this.series = e.series, this.currentState = e.currentState, this.nextState = e.nextState;
  }
}
class _e extends f {
  /**
   * @hidden
   */
  constructor(e, s) {
    super(s), this.series = e.series, this.seriesIndex = e.seriesIndex, this.pointIndex = e.pointIndex, this.text = e.text;
  }
  /**
   * If called, the series highlight is not shown as a result of hovering over the legend item.
   */
  preventDefault() {
    super.preventDefault();
  }
}
class we extends f {
  /**
   * @hidden
   */
  constructor(e, s) {
    super(s), this.series = e.series, this.seriesIndex = e.seriesIndex, this.pointIndex = e.pointIndex, this.text = e.text;
  }
  /**
   * If called, the series visibility is not toggled as a result of clicking the legend item.
   */
  preventDefault() {
    super.preventDefault();
  }
}
class ke extends f {
  /**
   * @hidden
   */
  constructor(e, s) {
    super(s), this.series = e.series, this.seriesIndex = e.seriesIndex, this.pointIndex = e.pointIndex, this.text = e.text;
  }
  /**
   * @hidden
   */
  preventDefault() {
    super.preventDefault();
  }
}
class De extends v {
  /**
   * Constructs the event arguments from a raw object.
   */
  constructor(e, s) {
    super(s), this.from = e.from, this.to = e.to;
  }
}
class Te extends v {
  /**
   * @hidden
   */
  constructor(e, s) {
    super(s), this.category = e.category, this.dataItem = e.dataItem, this.series = e.series, this.value = e.value, this.visual = e.visual;
  }
}
class Ae extends v {
  /**
   * @hidden
   */
  constructor(e, s) {
    super(s), this.category = e.category, this.dataItem = e.dataItem, this.series = e.series, this.value = e.value, this.visual = e.visual;
  }
}
class Ne extends v {
  /**
   * @hidden
   */
  constructor(e, s) {
    super(s), this.category = e.category, this.nativeEvent = e.originalEvent, this.value = e.value, this.x = e.x, this.y = e.y;
  }
}
class Oe extends v {
  /**
   * @hidden
   */
  constructor(e, s) {
    super(s), this.category = e.category, this.nativeEvent = e.originalEvent, this.value = e.value, this.x = e.x, this.y = e.y;
  }
}
class Ke extends v {
  /**
   * @hidden
   */
  constructor(e, s) {
    super(s);
  }
}
class Le extends f {
  /**
   * @hidden
   */
  constructor(e, s) {
    super(s), this.axis = e.axis, this.from = e.from, this.to = e.to;
  }
}
class Pe extends v {
  /**
   * @hidden
   */
  constructor(e, s) {
    super(s), this.axis = e.axis, this.from = e.from, this.to = e.to;
  }
}
class Re extends f {
  /**
   * @hidden
   */
  constructor(e, s) {
    super(s), this.axis = e.axis, this.from = e.from, this.to = e.to;
  }
}
class Fe extends v {
  // tslint:enable:max-line-length
  /**
   * @hidden
   */
  constructor(e, s) {
    super(s), this.category = e.category, this.dataItem = e.dataItem, this.nativeEvent = e.originalEvent, this.percentage = e.percentage, this.point = e.point, this.series = e.series, this.stackValue = e.stackValue, this.value = e.value;
  }
}
class Me extends f {
  /**
   * @hidden
   */
  constructor(e, s) {
    super(s), this.category = e.category, this.categoryPoints = e.categoryPoints, this.dataItem = e.dataItem, this.nativeEvent = e.originalEvent, this.percentage = e.percentage, this.point = e.point, this.series = e.series, this.stackValue = e.stackValue, this.value = e.value;
  }
}
class He extends f {
  // tslint:enable:max-line-length
  /**
   * @hidden
   */
  constructor(e, s) {
    super(s), this.axisRanges = e.axisRanges, this.delta = e.delta, this.nativeEvent = e.originalEvent;
  }
}
class Ve extends v {
  // tslint:enable:max-line-length
  /**
   * @hidden
   */
  constructor(e, s) {
    super(s), this.axisRanges = e.axisRanges, this.nativeEvent = e.originalEvent;
  }
}
class je extends f {
  // tslint:enable:max-line-length
  /**
   * @hidden
   */
  constructor(e, s) {
    super(s), this.axisRanges = e.axisRanges, this.nativeEvent = e.originalEvent;
  }
}
const K = {
  axisLabelClick: be,
  drag: Se,
  dragEnd: Ee,
  dragStart: Ie,
  drilldownEvent: V,
  legendItemHover: _e,
  legendItemClick: we,
  legendItemLeave: ke,
  navigatorFilter: De,
  noteClick: Te,
  noteHover: Ae,
  plotAreaClick: Ne,
  plotAreaHover: Oe,
  render: Ke,
  select: Le,
  selectEnd: Pe,
  selectStart: Re,
  seriesClick: Fe,
  seriesHover: Me,
  zoom: He,
  zoomEnd: Ve,
  zoomStart: je
};
function Be(t, e, s) {
  if (K[t])
    return new K[t](e, s);
}
class Ue {
  /**
   * @hidden
   */
  constructor(e, s) {
    this.sender = e, this.syntheticEvent = s;
  }
}
function j(t, e) {
  return new Ue(t, e);
}
const E = (t) => `${t.fontWeight} ${t.fontSize} ${t.fontFamily}`, L = (t) => window.getComputedStyle(t).backgroundColor, ze = (t) => t.toLowerCase().charCodeAt(0) - "a".charCodeAt(0), $e = (t) => {
  const e = t.match(/series-([a-z])$/);
  if (e !== null)
    return ze(e[1]);
  const s = t.split("--series-")[1];
  return parseInt(s, 10) - 1;
}, Xe = 30, We = () => {
  let t = `
      <div class="k-var--series-a"></div>
      <div class="k-var--series-b"></div>
      <div class="k-var--series-c"></div>
      <div class="k-var--series-d"></div>
      <div class="k-var--series-e"></div>
      <div class="k-var--series-f"></div>
`;
  for (let e = 0; e < Xe; e++)
    t += `
      <div class="k-var--series-${e + 1}"></div>`;
  return t;
}, Ye = `
    <div class="k-var--primary"></div>
    <div class="k-var--base"></div>
    <div class="k-var--background"></div>

    <div class="k-var--normal-background"></div>
    <div class="k-var--normal-text-color"></div>
    <div class="k-var--hover-background"></div>
    <div class="k-var--hover-text-color"></div>
    <div class="k-var--selected-background"></div>
    <div class="k-var--selected-text-color"></div>
    <div class="k-var--chart-error-bars-background"></div>
    <div class="k-var--chart-notes-background"></div>
    <div class="k-var--chart-notes-border"></div>
    <div class="k-var--chart-notes-lines"></div>
    <div class="k-var--chart-crosshair-background"></div>

    <div class="k-var--chart-inactive"></div>
    <div class="k-var--chart-major-lines"></div>
    <div class="k-var--chart-minor-lines"></div>
    <div class="k-var--chart-area-opacity"></div>
    <div class="k-var--chart-area-inactive-opacity"></div>
    <div class="k-var--chart-line-inactive-opacity"></div>

    <div class="k-widget k-chart">
        <div class="k-var--chart-font"></div>
        <div class="k-var--chart-title-font"></div>
        <div class="k-var--chart-pane-title-font"></div>
        <div class="k-var--chart-label-font"></div>
    </div>

    <div class="k-var--series-unset"></div>
    <div class="k-var--series">
      ${We()}
    </div>
`;
class qe {
  constructor(e) {
    this.store = e;
  }
  setStyle(e, s) {
    this.store.dispatch({ type: "set", payload: { field: e, value: s } });
  }
  setColors() {
    this.mapColor("axisDefaults.crosshair.color", "chart-crosshair-background"), this.mapColor("axisDefaults.labels.color", "normal-text-color"), this.mapColor("axisDefaults.line.color", "chart-major-lines"), this.mapColor("axisDefaults.majorGridLines.color", "chart-major-lines"), this.mapColor("axisDefaults.minorGridLines.color", "chart-minor-lines"), this.mapColor("axisDefaults.notes.icon.background", "chart-notes-background"), this.mapColor("axisDefaults.notes.icon.border.color", "chart-notes-border"), this.mapColor("axisDefaults.notes.line.color", "chart-notes-lines"), this.mapColor("axisDefaults.title.color", "normal-text-color"), this.mapColor("chartArea.background", "background"), this.mapColor("legend.inactiveItems.labels.color", "chart-inactive"), this.mapColor("legend.inactiveItems.markers.color", "chart-inactive"), this.mapColor("legend.labels.color", "normal-text-color"), this.mapColor("seriesDefaults.boxPlot.downColor", "chart-major-lines"), this.mapColor("seriesDefaults.boxPlot.mean.color", "base"), this.mapColor("seriesDefaults.boxPlot.median.color", "base"), this.mapColor("seriesDefaults.boxPlot.whiskers.color", "primary"), this.mapColor("seriesDefaults.bullet.target.color", "normal-text-color"), this.mapColor("seriesDefaults.candlestick.downColor", "normal-text-color"), this.mapColor("seriesDefaults.candlestick.line.color", "normal-text-color"), this.mapColor("seriesDefaults.errorBars.color", "chart-error-bars-background"), this.mapColor("seriesDefaults.horizontalWaterfall.line.color", "chart-major-lines"), this.mapColor("seriesDefaults.icon.border.color", "chart-major-lines"), this.mapColor("seriesDefaults.labels.background", "background"), this.mapColor("seriesDefaults.labels.color", "normal-text-color"), this.mapColor("seriesDefaults.notes.icon.background", "chart-notes-background"), this.mapColor("seriesDefaults.notes.icon.border.color", "chart-notes-border"), this.mapColor("seriesDefaults.notes.line.color", "chart-notes-lines"), this.mapColor("seriesDefaults.verticalBoxPlot.downColor", "chart-major-lines"), this.mapColor("seriesDefaults.verticalBoxPlot.mean.color", "base"), this.mapColor("seriesDefaults.verticalBoxPlot.median.color", "base"), this.mapColor("seriesDefaults.verticalBoxPlot.whiskers.color", "primary"), this.mapColor("seriesDefaults.verticalBullet.target.color", "normal-text-color"), this.mapColor("seriesDefaults.waterfall.line.color", "chart-major-lines"), this.mapColor("title.color", "normal-text-color"), this.mapColor("subtitle.color", "normal-text-color");
    const e = parseFloat(this.queryStyle("chart-area-opacity").opacity);
    isNaN(e) || (this.setStyle("seriesDefaults.area.opacity", e), this.setStyle("seriesDefaults.radarArea.opacity", e), this.setStyle("seriesDefaults.verticalArea.opacity", e), this.setStyle("seriesDefaults.labels.opacity", e)), this.setInactiveOpacity(["area", "verticalArea"], "chart-area-inactive-opacity"), this.setInactiveOpacity(["line", "verticalLine"], "chart-line-inactive-opacity");
  }
  setFonts() {
    const e = E(this.queryStyle("chart-font")), s = E(this.queryStyle("chart-title-font")), r = E(this.queryStyle("chart-pane-title-font")), a = E(this.queryStyle("chart-label-font"));
    this.setStyle("axisDefaults.labels.font", a), this.setStyle("axisDefaults.notes.label.font", e), this.setStyle("axisDefaults.title.font", e), this.setStyle("legend.labels.font", e), this.setStyle("seriesDefaults.labels.font", a), this.setStyle("seriesDefaults.notes.label.font", e), this.setStyle("title.font", s), this.setStyle("subtitle.font", r), this.setStyle("paneDefaults.title.font", r);
  }
  setSeriesColors() {
    const e = this.element, s = [].slice.call(e.querySelectorAll(".k-var--series div")), r = L(e.querySelector(".k-var--series-unset")), a = s.reduce(
      (i, c) => {
        const l = $e(c.className), h = L(c);
        return h !== r && (i[l] = h), i;
      },
      []
      // Will populate the series colors in this array
    );
    this.setStyle("seriesColors", a);
  }
  mapColor(e, s) {
    this.setStyle(e, this.queryStyle(s).backgroundColor);
  }
  queryStyle(e) {
    const s = this.element;
    return window.getComputedStyle(s.querySelector(`.k-var--${e}`));
  }
  setInactiveOpacity(e, s) {
    const r = parseFloat(this.queryStyle(s).opacity);
    !isNaN(r) && r < 1 && e.forEach(
      (a) => this.setStyle(`seriesDefaults.${a}.highlight.inactiveOpacity`, r)
    );
  }
}
const Ge = (t, e, s) => {
  const r = new qe(t);
  if (typeof s > "u") {
    t.dispatch({ type: "push", payload: T() });
    return;
  }
  const a = r.element = s.createElement("div");
  a.style.display = "none", a.innerHTML = Ye, s.body.appendChild(a);
  try {
    t.dispatch({ type: "push", payload: T() }), r.setColors(), r.setFonts(), r.setSeriesColors();
  } finally {
    s.body.removeChild(r.element), delete r.element, e();
  }
}, Ze = 1e3 / 60, Je = (t) => {
  let e, s, r = [];
  const a = () => e, i = (l) => {
    e = t(e, l), M && (window.clearTimeout(s), s = window.setTimeout(() => r.forEach((h) => h()), Ze));
  }, c = (l) => (r.push(l), () => r = r.filter((h) => h !== l));
  return i({}), { getState: a, dispatch: i, subscribe: c };
}, I = Je, B = (t, e) => e.chartCollectionIdxKey ? _.collectionConfigurationItem(t, e) : e.chartKey ? _.configurationItem(t, e) : {}, Qe = (t, e) => {
  if (e.type)
    switch (e.type) {
      case "set":
        return _.themeItem(t, e);
      case "push":
        return Object.assign(t, e.payload);
      default:
        return t;
    }
  else
    return {};
}, et = (t, e) => {
  if (e.type)
    switch (e.type) {
      case "add":
        return [...t, e.payload];
      case "remove":
        return t.filter((s) => s !== e.payload);
      default:
        return t;
    }
  else
    return [];
}, _ = {
  configurationItem(t, e) {
    return Object.assign(t, {
      [e.chartKey]: e.payload
    });
  },
  collectionConfigurationItem(t, e) {
    let s = !1;
    const [r, a] = e.chartCollectionIdxKey.split("_"), i = t[r].map((c, l) => parseInt(a, 10) === l ? (s = !0, e.payload) : c);
    return s === !1 && i.splice(parseInt(a, 10), 0, e.payload), Object.assign(t, {
      [r]: i
    });
  },
  themeItem(t, e) {
    let s = {}, r = Object.assign(s, t);
    const { field: a, value: i } = e.payload, c = a.split(".");
    let l = c.shift();
    for (; c.length > 0; )
      s = s[l] = s[l] || {}, l = c.shift();
    return s[l] = i, r;
  }
};
class P {
  /**
   * @hidden
   */
  constructor(e, s) {
    this.value = e.value, this.category = e.category, this.categoryIndex = e.categoryIx, this.series = e.series, this.dataItem = e.dataItem, this.percentage = e.percentage, this.runningTotal = e.runningTotal, this.total = e.total, this.low = e.low, this.high = e.high, this.xLow = e.xLow, this.xHigh = e.xHigh, this.yLow = e.yLow, this.yHigh = e.yHigh, this.point = e, this.format = ((e.options || {}).tooltip || {}).format || s;
  }
  get formattedValue() {
    return this.format ? this.point.formatValue(this.format) : String(this.value);
  }
}
const tt = "k-chart-shared-tooltip-marker", st = (t) => {
  const { categoryText: e, colorMarker: s, colspan: r, nameColumn: a, points: i } = t, c = (l, h) => /* @__PURE__ */ n.createElement("tr", { key: h }, s && /* @__PURE__ */ n.createElement("td", null, /* @__PURE__ */ n.createElement(
    "span",
    {
      className: tt,
      style: { backgroundColor: l.series.color }
    }
  )), a && /* @__PURE__ */ n.createElement("td", null, l.series.name), /* @__PURE__ */ n.createElement("td", { dangerouslySetInnerHTML: { __html: l.formattedValue } }));
  return /* @__PURE__ */ n.createElement("table", null, /* @__PURE__ */ n.createElement("thead", null, /* @__PURE__ */ n.createElement("tr", null, /* @__PURE__ */ n.createElement("th", { colSpan: r }, e))), /* @__PURE__ */ n.createElement("tbody", null, i.map(c)));
}, y = n.createContext(null);
y.displayName = "ChartContext";
const rt = { horizontal: "fit", vertical: "fit" }, nt = "k-chart-tooltip", at = "k-chart-tooltip-wrapper";
class w extends n.Component {
  constructor(e, s) {
    super(e, s), this.context = null, this.element = null, this.onChartMouseLeave = (r) => {
      const { syntheticEvent: a } = r;
      return !!H(a.relatedTarget, this.element);
    }, this.onMouseLeave = (r) => {
      const a = j(this, r);
      this.context.childrenObserver.trigger("onMouseLeave", a) && r.preventDefault();
    }, this.popupRef = (r) => {
      this.element = r;
      const a = r && r.closest(".k-animation-container");
      a && (a.style.transition = "initial");
    }, this.chartObserver = new x(this, {
      onMouseLeave: "onChartMouseLeave"
    }), s.observersStore.dispatch({
      type: "add",
      payload: this.chartObserver
    });
  }
  render() {
    const { popupShown: e, popupAlign: s, popupOffset: r, popupStyles: a, popupContent: i, className: c } = this.props, l = [nt, c].join(" ").trim();
    return /* @__PURE__ */ n.createElement(
      de,
      {
        animate: !1,
        popupAlign: s,
        offset: r,
        show: e,
        collision: rt,
        className: at
      },
      /* @__PURE__ */ n.createElement(
        "div",
        {
          className: l,
          style: a,
          onMouseLeave: this.onMouseLeave,
          ref: this.popupRef
        },
        i()
      )
    );
  }
  componentWillUnmount() {
    this.context.observersStore.dispatch({
      type: "remove",
      payload: this.chartObserver
    });
  }
}
w.contextType = y;
const it = "k-chart-shared-tooltip", ot = "k-chart-tooltip-inverse";
class U extends n.Component {
  constructor() {
    super(...arguments), this.context = null, this.state = {
      popupShown: !1
    }, this.chartObserver = null;
  }
  componentDidMount() {
    this.chartObserver = new x(this, {
      showTooltip: "onShowTooltip",
      hideTooltip: "onHideTooltip"
    }), this.context.observersStore.dispatch({
      type: "add",
      payload: this.chartObserver
    });
  }
  render() {
    const { popupContext: e, shared: s, className: r, ...a } = this.state, i = this.state.popupShown ? () => {
      const l = this.findRenderFunction();
      if (s)
        return l !== null ? l(e) : /* @__PURE__ */ n.createElement(st, { ...e });
      {
        const h = e.point, p = this.findRenderFunctionByIndex(h.series.index);
        return p !== null ? p(e) : l !== null ? l(e) : /* @__PURE__ */ n.createElement(
          "span",
          {
            dangerouslySetInnerHTML: { __html: e.point.formattedValue }
          }
        );
      }
    } : Function.prototype, c = S({
      [it]: s,
      [ot]: !!r
    });
    return /* @__PURE__ */ n.createElement(
      w,
      {
        ...a,
        popupContent: i,
        className: c
      }
    );
  }
  componentWillUnmount() {
    this.context.observersStore.dispatch({
      type: "remove",
      payload: this.chartObserver
    });
  }
  onShowTooltip(e) {
    const { anchor: s, style: r, shared: a, className: i, crosshair: c } = e;
    let l;
    c || (a ? l = this.createSharedTooltipContext(e) : l = this.createTooltipContext(e), this.setState({
      popupShown: !0,
      popupAlign: s.align,
      popupOffset: s.point,
      popupContext: l,
      popupStyles: r,
      className: i,
      shared: a
    }));
  }
  onHideTooltip() {
    this.setState({
      popupShown: !1,
      popupStyles: {},
      className: void 0
    });
  }
  createSharedTooltipContext(e) {
    const { points: s, categoryText: r } = e, a = s.filter((l) => typeof l.series.name < "u").length > 0, i = e.series.length > 1;
    let c = 1;
    return a && c++, i && c++, {
      categoryText: r,
      colorMarker: i,
      colspan: c,
      nameColumn: a,
      points: e.points.map((l) => new P(l, e.format))
    };
  }
  createTooltipContext(e) {
    const { point: s, format: r } = e;
    return { point: new P(s, r) };
  }
  findRenderFunctionByIndex(e) {
    const s = this.context.optionsStore.getState().series;
    return s !== void 0 && Array.isArray(s) && s[e] !== void 0 && s[e].hasOwnProperty("tooltip") && s[e].tooltip.hasOwnProperty("render") ? s[e].tooltip.render : null;
  }
  findRenderFunction() {
    const e = this.context.optionsStore.getState().tooltip;
    return e !== void 0 && e.hasOwnProperty("render") ? e.render : null;
  }
}
U.contextType = y;
const z = (t) => t.children;
z.displayName = "Container";
const lt = "k-chart-crosshair-tooltip", ct = "k-chart-tooltip-inverse";
class $ extends n.Component {
  constructor(e, s) {
    super(e, s), this.context = null, this.state = {
      popupShown: !1
    }, this.chartObserver = new x(this, {
      showTooltip: "onShowTooltip",
      hideTooltip: "onHideTooltip"
    }), s.observersStore.dispatch({
      type: "add",
      payload: this.chartObserver
    });
  }
  render() {
    const { popupContend: e, className: s, ...r } = this.state, a = this.state.popupShown ? () => e : Function.prototype, i = S({
      [lt]: !0,
      [ct]: !!s
    });
    return /* @__PURE__ */ n.createElement(
      w,
      {
        ...r,
        popupContent: a,
        className: i
      }
    );
  }
  componentWillUnmount() {
    var e;
    (e = this.context) == null || e.observersStore.dispatch({
      type: "remove",
      payload: this.chartObserver
    });
  }
  onShowTooltip(e) {
    const { anchor: s, style: r, className: a, crosshair: i, axisName: c, axisIndex: l, value: h } = e, { name: p, index: m } = this.props;
    i && c === p && l === m && this.setState({
      popupShown: !0,
      popupAlign: s.align,
      popupOffset: s.point,
      popupContend: h,
      popupStyles: r,
      className: a
    });
  }
  onHideTooltip() {
    this.setState({
      popupShown: !1,
      popupStyles: {},
      className: void 0
    });
  }
}
$.contextType = y;
const R = ["categoryAxis", "valueAxis", "xAxis", "yAxis"];
function ht(t) {
  const e = {};
  for (let s = 0; s < R.length; s++) {
    const r = pt(t, R[s]);
    for (let a = 0; a < r.length; a++) {
      const i = r[a];
      e[i.name + i.index] = i;
    }
  }
  return e;
}
function pt(t, e) {
  const s = [];
  if (t[e]) {
    const r = [].concat(t[e]);
    for (let a = 0; a < r.length; a++) {
      const i = (r[a].crosshair || {}).tooltip;
      i && i.visible && s.push({
        index: a,
        name: e
      });
    }
  }
  return s;
}
class X extends n.Component {
  constructor() {
    super(...arguments), this.context = null, this.state = {
      tooltips: {}
    }, this.storeUnsubscriber = Function.prototype, this.subscriber = () => {
      var e;
      this.setState({
        tooltips: ht((e = this.context) == null ? void 0 : e.optionsStore.getState())
      });
    };
  }
  componentDidMount() {
    this.storeUnsubscriber = this.context.optionsStore.subscribe(this.subscriber);
  }
  render() {
    const { tooltips: e } = this.state, s = Object.keys(e).map((r) => /* @__PURE__ */ n.createElement($, { ...e[r], key: r }));
    return /* @__PURE__ */ n.createElement(z, null, s);
  }
  componentWillUnmount() {
    this.storeUnsubscriber();
  }
}
X.contextType = y;
const F = {
  name: "@progress/kendo-react-charts",
  productName: "KendoReact",
  productCodes: ["KENDOUIREACT", "KENDOUICOMPLETE"],
  publishDate: 1702645200,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-react-ui/components/my-license/"
};
class b extends n.Component {
  constructor(e) {
    super(e), this.chartInstance = null, this.surface = null, this._element = null, this.optionsStore = {}, this.optionsUnsubscriber = Function.prototype, this.themeStore = {}, this.themeUnsubscriber = Function.prototype, this.observersStore = {}, this.suppressTransitions = !1, this.showLicenseWatermark = !1, this.onRender = (s) => {
      this.chartInstance !== null && (this.surface = s.sender.surface, this.trigger("render", s));
    }, this.onDrilldown = (s) => {
      var c;
      const { series: r } = this.optionsStore.getState(), a = r.find((l) => l.name === s.series.name);
      if (!a.drilldownSeriesFactory)
        return !0;
      const i = "onDrilldown";
      if (this.props.hasOwnProperty(i)) {
        const l = { seriesName: a.name, drilldownValue: s.value }, h = [...((c = this.props.drilldownState) == null ? void 0 : c.steps) || [], l], p = this.props.getTarget(), m = {
          ...s,
          currentState: this.props.drilldownState,
          nextState: { steps: h }
        }, u = new V(m, p);
        this.props[i].call(void 0, u);
      }
      return !0;
    }, this.onLegendItemClick = (s) => {
      if (this.chartInstance !== null)
        if (this.props.onLegendItemClick)
          this.trigger("legendItemClick", s);
        else {
          const { series: r } = this.optionsStore.getState();
          if (!r)
            return;
          let a = {};
          const { seriesIndex: i, pointIndex: c } = s, l = r[i];
          if (c === void 0)
            a = Object.assign({}, l, { visible: N(l.visible) });
          else {
            const h = l.pointVisibility = l.pointVisibility || [];
            h[c] = N(h[c]), a = Object.assign({}, l);
          }
          this.optionsStore.dispatch({
            chartCollectionIdxKey: `series_${i}`,
            payload: a
          }), this.suppressTransitions = !0;
        }
    }, this.onWindowResize = () => {
      this.chartInstance !== null && this.chartInstance.resize();
    }, this.onChartMouseLeave = (s) => {
      const r = j(this, s);
      this.triggerDomEvent("onMouseLeave", r) ? s.preventDefault() : this.chartInstance !== null && this.chartInstance.hideElements();
    }, this.onChildMouseLeave = (s) => {
      const { syntheticEvent: r } = s;
      return this.chartInstance && !H(r.relatedTarget, this.element) && this.chartInstance.hideElements(), !1;
    }, le(F), this.showLicenseWatermark = ce(F), this.optionsStore = I(B), this.observersStore = I(et), this.childrenObserver = new x(this, { onMouseLeave: "onChildMouseLeave" }), this.state = {
      optionsStore: this.optionsStore,
      observersStore: this.observersStore,
      childrenObserver: this.childrenObserver,
      drilldownState: { steps: [] }
    }, this.themeStore = I(Qe), this.chartObserver = new x(this, {
      render: "onRender",
      legendItemClick: "onLegendItemClick",
      drilldown: "onDrilldown"
    });
  }
  /**
   * @hidden
   */
  get element() {
    return this._element;
  }
  /**
   * @hidden
   */
  static getDerivedStateFromProps(e, s) {
    return {
      ...s,
      drilldownState: e.drilldownState || []
    };
  }
  /**
   * @hidden
   */
  componentDidMount() {
    var s;
    const e = ((s = this._element) == null ? void 0 : s.ownerDocument) || document;
    Ge(this.themeStore, this.instantiateCoreChart.bind(this), e), this.optionsUnsubscriber = this.optionsStore.subscribe(this.refresh.bind(this)), this.themeUnsubscriber = this.themeStore.subscribe(this.refresh.bind(this)), window.addEventListener("resize", this.onWindowResize);
  }
  /**
   * @hidden
   */
  componentWillUnmount() {
    this.optionsUnsubscriber(), this.themeUnsubscriber(), this.chartInstance !== null && (this.chartInstance.destroy(), this.chartInstance = null), window.removeEventListener("resize", this.onWindowResize);
  }
  /**
   * @hidden
   */
  componentDidUpdate(e) {
    const { dir: s, children: r, ...a } = this.props;
    if (this.chartInstance !== null) {
      const i = D(this), c = this.chartInstance.chartService, l = i.locale !== c._intlService.locale, h = Object.entries(e).filter((p) => p[0] !== "dir" && p[0] !== "children").some((p) => {
        const [m, u] = p;
        return !(a.hasOwnProperty(m) && a[m] === u);
      });
      l && (this.chartInstance.chartService._intlService = i, this.chartInstance.chartService.format._intlService = i, h || this.chartInstance.noTransitionsRedraw()), h && this.refresh(), e.dir !== s && this.chartInstance.setDirection(this.getDirection(s));
    }
  }
  /**
   * @hidden
   */
  render() {
    const { style: e = {}, className: s, wrapper: r, children: a } = this.props, i = Object.assign({}, e, { position: "relative" }), c = n.createElement(
      r,
      {
        className: s,
        style: i,
        key: "chartElement"
      },
      /* @__PURE__ */ n.createElement(
        "div",
        {
          onMouseLeave: this.onChartMouseLeave,
          ref: (l) => this._element = l,
          className: "k-chart-surface"
        },
        a
      ),
      /* @__PURE__ */ n.createElement(n.Fragment, null, this.showLicenseWatermark && /* @__PURE__ */ n.createElement(he, null))
    );
    return /* @__PURE__ */ n.createElement(y.Provider, { value: this.state }, /* @__PURE__ */ n.createElement(U, { key: "seriesTooltip" }), /* @__PURE__ */ n.createElement(X, { key: "crosshairTooltips" }), c);
  }
  /**
   * @hidden
   */
  getDirection(e) {
    return (e !== void 0 ? e : (() => M && window.getComputedStyle(this.element).direction)() || "ltr") === "rtl";
  }
  /**
   * @hidden
   */
  getChartOptions() {
    const {
      renderAs: e,
      pannable: s,
      zoomable: r,
      paneDefaults: a,
      panes: i,
      transitions: c,
      seriesColors: l,
      seriesDefaults: h,
      axisDefaults: p,
      deriveOptionsFromParent: m
    } = this.props;
    let u = {};
    return e !== void 0 && (u.renderAs = e), s !== void 0 && (u.pannable = s), r !== void 0 && (u.zoomable = r), a !== void 0 && (u.paneDefaults = a), i !== void 0 && (u.panes = i), c !== void 0 && (u.transitions = c), l !== void 0 && (u.seriesColors = l), h !== void 0 && (u.seriesDefaults = h), p !== void 0 && (u.axisDefaults = p), u = Object.assign(u, this.optionsStore.getState()), m && (u = m(u)), u;
  }
  /**
   * @hidden
   */
  refresh() {
    if (this.chartInstance !== null) {
      const e = this.themeStore.getState(), s = this.getChartOptions(), r = s.transitions;
      this.suppressTransitions && (s.transitions = !1), this.props.onRefresh ? this.props.onRefresh.call(void 0, s, e, this.chartInstance) : this.chartInstance.setOptions(s, e), this.suppressTransitions && (s.transitions = r, this.suppressTransitions = !1);
    }
  }
  /**
   * @hidden
   */
  instantiateCoreChart() {
    const { dir: e, chartConstructor: s } = this.props, r = this.getChartOptions();
    this.chartInstance = new s(
      this.element,
      r,
      this.themeStore.getState(),
      {
        rtl: this.getDirection(e),
        intlService: D(this),
        observer: this.chartObserver,
        sender: this
      }
    );
  }
  /* Triggers public dom event handlers */
  /**
   * @hidden
   */
  trigger(e, s) {
    const r = this.props.getTarget(), a = Be(e, s, r), i = "on" + e.charAt(0).toUpperCase() + e.slice(1), c = this.observersStore.getState();
    let l = !1;
    for (let h = 0; h < c.length; h++)
      c[h].trigger(e, s) && (l = !0);
    return l === !1 && a && this.props.hasOwnProperty(i) ? (this.props[i].call(void 0, a), a.isDefaultPrevented && a.isDefaultPrevented()) : l;
  }
  /* Used by (event)InstanceObserver to check the wrapper for supported events */
  /**
   * @hidden
   */
  requiresHandlers(e) {
    for (let s = 0; s < e.length; s++) {
      const r = e[s], a = "on" + r.charAt(0).toUpperCase() + r.slice(1);
      if (this.props.hasOwnProperty(a))
        return !0;
    }
    return !1;
  }
  /* Triggers private dom event handlers */
  /**
   * @hidden
   */
  triggerDomEvent(e, s) {
    const r = this.observersStore.getState();
    let a = !1;
    for (let i = 0; i < r.length; i++)
      r[i].trigger(e, s) && (a = !0);
    return a;
  }
}
b.propTypes = {
  dir: d.string,
  renderAs: d.oneOf(["svg", "canvas"])
};
b.defaultProps = {
  renderAs: "svg"
};
ne(b);
ae.register(xe);
class W extends n.Component {
  constructor(e, s) {
    super(e, s), this.context = null, this.state = {
      donutCenterStyles: null
    }, this.chartObserver = new x(this, {
      render: "onRender"
    }), s.observersStore.dispatch({
      type: "add",
      payload: this.chartObserver
    });
  }
  render() {
    const { render: e } = this.props, { donutCenterStyles: s } = this.state;
    let r = null;
    return e && s && (r = /* @__PURE__ */ n.createElement("div", { className: "k-chart-donut-center", style: s }, /* @__PURE__ */ n.createElement(e, null))), r;
  }
  onRender(e) {
    var m;
    const s = (m = this.context) == null ? void 0 : m.optionsStore.getState().series, r = Array.isArray(s) ? s[0] : null, a = e.sender._plotArea.charts;
    if (!r || r.type !== "donut" || a[0].points.length === 0)
      return;
    const i = a[0].points[0].sector, c = i.innerRadius, l = i.center.y - c, h = i.center.x - c, p = c * 2;
    this.setState({
      donutCenterStyles: {
        height: p,
        left: h,
        top: l,
        width: p
      }
    });
  }
}
W.contextType = y;
class $t extends n.Component {
  constructor() {
    super(...arguments), this._baseChart = null, this.getTarget = () => this;
  }
  /**
   * @hidden
   */
  get chartInstance() {
    return this._baseChart !== null ? this._baseChart.chartInstance : null;
  }
  /**
   * The Drawing `Surface` of the Chart.
   */
  get surface() {
    return this._baseChart !== null ? this._baseChart.surface : null;
  }
  /**
   * The DOM element of the Chart.
   */
  get element() {
    return this._baseChart !== null ? this._baseChart.element : null;
  }
  /**
   * @hidden
   */
  render() {
    const { donutCenterRender: e, children: s, className: r, ...a } = this.props;
    return /* @__PURE__ */ n.createElement(
      b,
      {
        ...a,
        ref: (i) => this._baseChart = i,
        chartConstructor: ie,
        getTarget: this.getTarget,
        wrapper: "div",
        className: S("k-chart k-widget", r)
      },
      s,
      /* @__PURE__ */ n.createElement(W, { render: e })
    );
  }
}
class Xt extends n.Component {
  constructor() {
    super(...arguments), this._baseChart = null, this.deriveOptionsFromParent = (e) => {
      const { type: s, data: r } = this.props, a = Object.assign({}, e, { type: s, data: r });
      return A.normalizeOptions(a);
    }, this.getTarget = () => this;
  }
  /**
   * @hidden
   */
  get chartInstance() {
    return this._baseChart !== null ? this._baseChart.chartInstance : null;
  }
  /**
   * The Drawing `Surface` of the Sparkline.
   */
  get surface() {
    return this._baseChart !== null ? this._baseChart.surface : null;
  }
  /**
   * The DOM element of the Sparkline.
   */
  get element() {
    return this._baseChart !== null ? this._baseChart.element : null;
  }
  /**
   * @hidden
   */
  render() {
    const { children: e, type: s, className: r, ...a } = this.props;
    return /* @__PURE__ */ n.createElement(
      b,
      {
        ...a,
        ref: (i) => this._baseChart = i,
        chartConstructor: A,
        getTarget: this.getTarget,
        wrapper: "span",
        deriveOptionsFromParent: this.deriveOptionsFromParent,
        className: S("k-sparkline k-widget", r)
      },
      e
    );
  }
}
const dt = {
  autoBindElements: !0,
  liveDrag: !1,
  partialRedraw: !0
};
class Wt extends n.Component {
  constructor() {
    super(...arguments), this._baseChart = null, this.deriveOptionsFromParent = (e) => {
      const s = Object.assign({}, e.navigator || {}, dt);
      return Object.assign({}, e, { navigator: s });
    }, this.onRefresh = (e, s, r) => {
      this.props.partialRedraw ? (r.applyOptions(e), r.bindCategories(), r.navigator.redrawSlaves()) : r.setOptions(e, s);
    }, this.getTarget = () => this;
  }
  /**
   * @hidden
   */
  get chartInstance() {
    return this._baseChart !== null ? this._baseChart.chartInstance : null;
  }
  /**
   * The Drawing `Surface` of the StockChart.
   */
  get surface() {
    return this._baseChart !== null ? this._baseChart.surface : null;
  }
  /**
   * The DOM element of the StockChart.
   */
  get element() {
    return this._baseChart !== null ? this._baseChart.element : null;
  }
  /**
   * @hidden
   */
  render() {
    const { children: e, className: s, ...r } = this.props;
    return /* @__PURE__ */ n.createElement(
      b,
      {
        ...r,
        ref: (a) => this._baseChart = a,
        chartConstructor: oe,
        getTarget: this.getTarget,
        wrapper: "div",
        deriveOptionsFromParent: this.deriveOptionsFromParent,
        onRefresh: this.onRefresh,
        className: S("k-stockchart k-widget", s)
      },
      e
    );
  }
}
class g extends n.Component {
  constructor(e, s) {
    super(e, s), this.optionsStore = s.optionsStore;
  }
  renderChildren(e, s) {
    const { children: r } = e.props, { _chartKey: a, _parentStore: i } = this.props, c = {
      ...e.props,
      _chartCollectionIdxKey: `${a}_${s}`,
      _parentStore: i
    };
    return n.cloneElement(e, c, r);
  }
  render() {
    const { _chartKey: e, _parentStore: s, children: r } = this.props;
    return (s || this.optionsStore).dispatch({
      chartKey: e,
      payload: []
    }), n.Children.map(r, (i, c) => n.isValidElement(i) ? this.renderChildren(i, c) : i);
  }
}
g.contextType = y;
class o extends n.Component {
  constructor(e, s) {
    super(e, s), this.optionsStore = s.optionsStore, this.childStore = I(B);
  }
  render() {
    const { children: e } = this.props;
    return e !== void 0 ? n.Children.map(e, (s) => n.isValidElement(s) ? this.renderChildren(s) : s) : null;
  }
  componentDidMount() {
    this.dispatch();
  }
  componentDidUpdate() {
    this.dispatch();
  }
  dispatch() {
    const { _chartKey: e, _chartCollectionIdxKey: s, _parentStore: r, children: a, ...i } = this.props;
    (r || this.optionsStore).dispatch({
      chartKey: e,
      chartCollectionIdxKey: s,
      payload: Object.assign({}, i, this.childStore.getState())
    });
  }
  renderChildren(e) {
    const { children: s } = e.props, r = {
      ...e.props,
      _parentStore: this.childStore
    };
    return n.cloneElement(e, r, s);
  }
}
o.contextType = y;
class ut {
  /**
   * @hidden
   */
  constructor(e) {
    this.currentState = e.currentState, this.nextState = e.nextState;
  }
}
const k = n.forwardRef((t, e) => {
  const s = n.useRef(null), r = n.useRef(null);
  n.useImperativeHandle(s, () => ({
    element: r.current,
    props: t
  })), n.useImperativeHandle(e, () => s.current);
  let i = [{
    id: "0",
    ...t.rootItem || {
      text: "Home",
      icon: /* @__PURE__ */ n.createElement(
        pe,
        {
          icon: me,
          style: { marginInlineEnd: "4px" }
        }
      )
    }
  }];
  t.drilldownState && (i = [...i, ...t.drilldownState.steps.map((h, p) => ({ id: (p + 1).toString(), text: h.drilldownValue }))]);
  const c = { ...t, data: i }, l = (h) => {
    var m;
    const p = "onDrilldownStateChange";
    if (t.hasOwnProperty(p)) {
      const u = i.findIndex((re) => re.id === h.id), te = { steps: (((m = t.drilldownState) == null ? void 0 : m.steps) || []).slice(0, u) }, se = new ut({ currentState: t.drilldownState, nextState: te });
      t[p].call(void 0, se);
    }
  };
  return /* @__PURE__ */ n.createElement("div", null, /* @__PURE__ */ n.createElement(ue, { ...c, onItemSelect: l }));
}), mt = {
  id: d.string,
  style: d.object,
  className: d.string,
  breadcrumbOrderedList: d.elementType,
  breadcrumbListItem: d.elementType,
  breadcrumbDelimiter: d.elementType,
  breadcrumbLink: d.elementType,
  dir: d.oneOf(["ltr", "rtl"]),
  disabled: d.bool,
  valueField: d.string,
  textField: d.string,
  iconField: d.string,
  iconClassField: d.string,
  onItemSelect: d.func,
  ariaLabel: d.string,
  onDrilldownStateChange: d.func,
  drilldownState: d.shape({
    steps: d.array
  }),
  rootItem: d.object
}, vt = {
  valueField: "id",
  textField: "text",
  iconField: "icon",
  iconClassField: "iconClass",
  data: []
};
k.displayName = "KendoReactChartBreadcrumb";
k.propTypes = mt;
k.defaultProps = vt;
const Yt = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "chartArea" }), qt = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "axisDefaults" }), Y = (t) => /* @__PURE__ */ n.createElement(o, { ...t });
Y.displayName = "ChartCategoryAxisItem";
const ft = (t) => /* @__PURE__ */ n.createElement(g, { ...t, _chartKey: "categoryAxis" });
ft.propTypes = {
  children: function(t, e, s) {
    return C(t, e, s, Y);
  }
};
const Gt = (t) => /* @__PURE__ */ n.createElement(o, { visible: !0, ...t, _chartKey: "legend" }), Zt = (t) => /* @__PURE__ */ n.createElement(o, { visible: !0, position: "bottom", ...t, _chartKey: "navigator" }), q = (t) => /* @__PURE__ */ n.createElement(o, { ...t });
q.displayName = "ChartPane";
const yt = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "paneDefaults" });
yt.displayName = "ChartPaneDefaults";
const gt = (t) => /* @__PURE__ */ n.createElement(g, { ...t, _chartKey: "panes" });
gt.propTypes = {
  children: function(t, e, s) {
    return C(t, e, s, q);
  }
};
const Jt = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "plotArea" }), G = (t) => {
  let e = (r) => /* @__PURE__ */ n.createElement(n.Fragment, null);
  t.drilldownSeriesFactory && (e = t.drilldownSeriesFactory);
  const s = (r) => {
    var a, i;
    return r && ((i = (a = r.drilldownState) == null ? void 0 : a.steps) == null ? void 0 : i.find(({ seriesName: c }) => c === t.name));
  };
  return /* @__PURE__ */ n.createElement(y.Consumer, null, (r) => s(r) ? /* @__PURE__ */ n.createElement(
    e,
    {
      _chartCollectionIdxKey: t._chartCollectionIdxKey,
      drilldownValue: s(r).drilldownValue
    }
  ) : /* @__PURE__ */ n.createElement(o, { ...t }));
};
G.displayName = "ChartSeriesItem";
const Ct = (t) => /* @__PURE__ */ n.createElement(g, { ...t, _chartKey: "series" });
Ct.propTypes = {
  children: function(t, e, s) {
    return C(t, e, s, G);
  }
};
const Qt = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "seriesDefaults" }), es = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "subtitle" }), ts = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "title" }), ss = (t) => /* @__PURE__ */ n.createElement(o, { visible: !0, ...t, _chartKey: "tooltip" }), Z = (t) => /* @__PURE__ */ n.createElement(o, { ...t });
Z.displayName = "ChartValueAxisItem";
const xt = (t) => /* @__PURE__ */ n.createElement(g, { ...t, _chartKey: "valueAxis" });
xt.propTypes = {
  children: function(t, e, s) {
    return C(t, e, s, Z);
  }
};
const J = (t) => /* @__PURE__ */ n.createElement(o, { ...t });
J.displayName = "ChartXAxisItem";
const bt = (t) => /* @__PURE__ */ n.createElement(g, { ...t, _chartKey: "xAxis" });
bt.prototype = {
  children: function(t, e, s) {
    return C(t, e, s, J);
  }
};
const Q = (t) => /* @__PURE__ */ n.createElement(o, { ...t });
Q.displayName = "ChartYAxisItem";
const St = (t) => /* @__PURE__ */ n.createElement(g, { ...t, _chartKey: "yAxis" });
St.propTypes = {
  children: function(t, e, s) {
    return C(t, e, s, Q);
  }
};
const rs = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "zoomable" }), Et = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "title" });
Et.displayName = "ChartAxisDefaultsTitle";
const It = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "labels" });
It.displayName = "ChartAxisDefaultsLabels";
const _t = (t) => /* @__PURE__ */ n.createElement(o, { visible: !0, ...t, _chartKey: "crosshair" });
_t.displayName = "ChartAxisDefaultsCrosshair";
const wt = (t) => /* @__PURE__ */ n.createElement(o, { visible: !0, ...t, _chartKey: "tooltip" });
wt.displayName = "ChartAxisDefaultsCrosshairTooltip";
const ns = (t) => /* @__PURE__ */ n.createElement(o, { visible: !0, ...t, _chartKey: "crosshair" }), as = (t) => /* @__PURE__ */ n.createElement(o, { visible: !0, ...t, _chartKey: "tooltip" }), kt = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "title" });
kt.displayName = "ChartCategoryAxisTitle";
const is = (t) => /* @__PURE__ */ n.createElement(o, { visible: !0, ...t, _chartKey: "labels" }), os = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "notes" }), ls = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "icon" }), cs = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "label" }), hs = (t) => /* @__PURE__ */ n.createElement(o, { visible: !0, ...t, _chartKey: "rangeLabels" }), Dt = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "title" });
Dt.displayName = "ChartPaneDefaultsTitle";
const Tt = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "item" });
Tt.displayName = "ChartLegendItem";
const At = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "title" });
At.displayName = "ChartLegendTitle";
const Nt = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "inactiveItems" });
Nt.displayName = "ChartLegendInactiveItems";
const ps = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "tooltip" }), ds = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "outliers" }), us = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "notes" }), ms = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "markers" }), vs = (t) => /* @__PURE__ */ n.createElement(o, { visible: !0, ...t, _chartKey: "labels" }), fs = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "highlight" }), ys = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "extremes" }), gs = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "errorBars" }), Cs = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "from" }), xs = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "to" }), bs = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "label" }), Ss = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "icon" }), Es = (t) => /* @__PURE__ */ n.createElement(o, { visible: !0, ...t, _chartKey: "crosshair" }), Is = (t) => /* @__PURE__ */ n.createElement(o, { visible: !0, ...t, _chartKey: "tooltip" }), _s = (t) => /* @__PURE__ */ n.createElement(o, { visible: !0, ...t, _chartKey: "labels" }), ws = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "notes" }), ks = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "icon" }), Ds = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "label" }), Ot = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "title" });
Ot.displayName = "ChartValueAxisTitle";
const Ts = (t) => /* @__PURE__ */ n.createElement(o, { visible: !0, ...t, _chartKey: "crosshair" }), As = (t) => /* @__PURE__ */ n.createElement(o, { visible: !0, ...t, _chartKey: "tooltip" }), Ns = (t) => /* @__PURE__ */ n.createElement(o, { visible: !0, ...t, _chartKey: "labels" }), Os = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "notes" }), Ks = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "icon" }), Ls = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "label" }), Kt = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "title" });
Kt.displayName = "ChartXAxisTitle";
const Ps = (t) => /* @__PURE__ */ n.createElement(o, { visible: !0, ...t, _chartKey: "crosshair" }), Rs = (t) => /* @__PURE__ */ n.createElement(o, { visible: !0, ...t, _chartKey: "tooltip" }), Fs = (t) => /* @__PURE__ */ n.createElement(o, { visible: !0, ...t, _chartKey: "labels" }), Ms = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "notes" }), Hs = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "icon" }), Vs = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "label" }), Lt = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "title" });
Lt.displayName = "ChartYAxisTitle";
const Pt = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "categoryAxis" });
Pt.displayName = "ChartNavigatorCategoryAxis";
const js = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "hint" }), Rt = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "pane" });
Rt.displayName = "ChartNavigatorPane";
const Bs = (t) => /* @__PURE__ */ n.createElement(o, { ...t, _chartKey: "select" }), ee = (t) => /* @__PURE__ */ n.createElement(o, { ...t });
ee.displayName = "ChartNavigatorSeriesItem";
const Ft = (t) => /* @__PURE__ */ n.createElement(g, { ...t, _chartKey: "series" });
Ft.propTypes = {
  children: function(t, e, s) {
    return C(t, e, s, ee);
  }
};
const Us = (t, e) => {
  if (t && t.chartInstance !== null)
    return t.chartInstance.findAxisByName(e);
}, zs = (t, e) => {
  if (t && t.chartInstance !== null)
    return t.chartInstance.findPaneByIndex(e);
}, $s = (t, e) => {
  if (t && t.chartInstance !== null)
    return t.chartInstance.findPaneByName(e);
}, Xs = (t, e = {}) => {
  if (t && t.chartInstance !== null)
    return t.chartInstance.exportVisual(e);
};
export {
  be as AxisLabelClickEvent,
  $t as Chart,
  Yt as ChartArea,
  qt as ChartAxisDefaults,
  _t as ChartAxisDefaultsCrosshair,
  wt as ChartAxisDefaultsCrosshairTooltip,
  It as ChartAxisDefaultsLabels,
  Et as ChartAxisDefaultsTitle,
  k as ChartBreadcrumb,
  ft as ChartCategoryAxis,
  ns as ChartCategoryAxisCrosshair,
  as as ChartCategoryAxisCrosshairTooltip,
  Y as ChartCategoryAxisItem,
  is as ChartCategoryAxisLabels,
  os as ChartCategoryAxisNotes,
  ls as ChartCategoryAxisNotesIcon,
  cs as ChartCategoryAxisNotesLabel,
  hs as ChartCategoryAxisRangeLabels,
  kt as ChartCategoryAxisTitle,
  Gt as ChartLegend,
  Nt as ChartLegendInactiveItems,
  Tt as ChartLegendItem,
  At as ChartLegendTitle,
  Zt as ChartNavigator,
  Pt as ChartNavigatorCategoryAxis,
  js as ChartNavigatorHint,
  Rt as ChartNavigatorPane,
  Bs as ChartNavigatorSelect,
  Ft as ChartNavigatorSeries,
  ee as ChartNavigatorSeriesItem,
  q as ChartPane,
  yt as ChartPaneDefaults,
  Dt as ChartPaneDefaultsTitle,
  gt as ChartPanes,
  Jt as ChartPlotArea,
  Ct as ChartSeries,
  Qt as ChartSeriesDefaults,
  gs as ChartSeriesErrorBars,
  ys as ChartSeriesExtremes,
  fs as ChartSeriesHighlight,
  G as ChartSeriesItem,
  ds as ChartSeriesItemOutliers,
  ps as ChartSeriesItemTooltip,
  vs as ChartSeriesLabels,
  Cs as ChartSeriesLabelsFrom,
  xs as ChartSeriesLabelsTo,
  ms as ChartSeriesMarkers,
  us as ChartSeriesNotes,
  Ss as ChartSeriesNotesIcon,
  bs as ChartSeriesNotesLabel,
  es as ChartSubtitle,
  ts as ChartTitle,
  ss as ChartTooltip,
  xt as ChartValueAxis,
  Es as ChartValueAxisCrosshair,
  Is as ChartValueAxisCrosshairTooltip,
  Z as ChartValueAxisItem,
  _s as ChartValueAxisLabels,
  ws as ChartValueAxisNotes,
  ks as ChartValueAxisNotesIcon,
  Ds as ChartValueAxisNotesLabel,
  Ot as ChartValueAxisTitle,
  bt as ChartXAxis,
  Ts as ChartXAxisCrosshair,
  As as ChartXAxisCrosshairTooltip,
  J as ChartXAxisItem,
  Ns as ChartXAxisLabels,
  Os as ChartXAxisNotes,
  Ks as ChartXAxisNotesIcon,
  Ls as ChartXAxisNotesLabel,
  Kt as ChartXAxisTitle,
  St as ChartYAxis,
  Ps as ChartYAxisCrosshair,
  Rs as ChartYAxisCrosshairTooltip,
  Q as ChartYAxisItem,
  Fs as ChartYAxisLabels,
  Ms as ChartYAxisNotes,
  Hs as ChartYAxisNotesIcon,
  Vs as ChartYAxisNotesLabel,
  Lt as ChartYAxisTitle,
  rs as ChartZoomable,
  g as CollectionConfigurationComponent,
  o as ConfigurationComponent,
  $ as CrosshairTooltip,
  X as CrosshairTooltipContainer,
  W as DonutCenter,
  Ee as DragEndEvent,
  Se as DragEvent,
  Ie as DragStartEvent,
  V as DrilldownEvent,
  ut as DrilldownStateChangeEvent,
  we as LegendItemClickEvent,
  _e as LegendItemHoverEvent,
  De as NavigatorFilterEvent,
  Te as NoteClickEvent,
  Ae as NoteHoverEvent,
  Ne as PlotAreaClickEvent,
  Oe as PlotAreaHoverEvent,
  Ke as RenderEvent,
  Pe as SelectEndEvent,
  Le as SelectEvent,
  Re as SelectStartEvent,
  Fe as SeriesClickEvent,
  Me as SeriesHoverEvent,
  U as SeriesTooltip,
  st as SharedTooltipContent,
  Xt as Sparkline,
  Wt as StockChart,
  P as TooltipPoint,
  w as TooltipPopup,
  Ve as ZoomEndEvent,
  He as ZoomEvent,
  je as ZoomStartEvent,
  Xs as exportVisual,
  Us as findAxisByName,
  zs as findPaneByIndex,
  $s as findPaneByName
};
